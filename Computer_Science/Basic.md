# 计算机工程世界观（静态公理层）

## 1. 什么是计算机

在工程系统语境中：计算机是一种通过物理可实现的确定性机制，对离散信息状态进行表示、存储、转换与控制的通用工程系统。

该定义强调计算机的四个核心要素：

- 物理可实现性
- 确定性
- 离散状态
- 通用性

让我们对这句话进行拆解：

### 工程系统

一个工程系统，必须满足：
- 可预测
- 可重复
- 可控制
- 可扩展

计算机最重要的不是“智能”，而是**极度可控**

### 信息状态

- 状态 --> 系统在某一时刻内的全部内部情况
- 信息 --> 对状态的抽象描述

计算机只进行**状态的操纵**。

### 确定性 (Determinism)

确定性是**工程的底线**，也是**工程系统可被设计、验证和复现的前提条件**。

确定性指的是**在相同的初始状态与相同输入条件下，系统的状态演化路径是唯一确定的。**

没有确定性，就无法调试、无法复现、无法扩展，也无法工程复用。

### 离散状态与工程可控性

计算机系统基于**离散状态空间**，原因在于：

- 离散状态可以被可靠区分
- 离散状态可以被精确复制
- 离散状态可以被形式化建模

连续系统难以满足工程控制需求，因此被抽象、量化或离散化。

### 信息处理

计算机对信息的处理，可以被工程化地拆分为四类操作：

- **表示 (Representation)**  
将物理状态映射为离散符号
- **存储 (Storage)**  
在时间维度上保持状态
- **转换 (Transformation)**  
按规则转变状态
- **控制 (Control)**
决定何时、以何种顺序进行状态转换

这四类操作定义了计算机系统边界的能力。

### 通用性 (Generaliity)

**通用性不是能力更强，而是约束更少。**

计算机的“通用性”来源于：

- 状态转换规则可以被描述为数据
- 控制行为逻辑可以被重配置
- 行为由外部输入定义

也就是说：**程序本身也是信息状态。**

### 程序

**程序是对状态空间及其转换规则的形式化描述。**

程序不是“指令列表”，而是对系统行为的约束，以及对状态演化路径的编码。

### 计算机的一级公理

计算机系统 = 离散状态空间

- 确定性状态转换机制
- 可配置的控制规则

> 需要注意的是，**计算机不具备认知属性**，所有的“智能”，“理解”，“决策”都是观察者施加的语义解释，而非系统属性。

---


## 2. 信息、状态与二进制

计算机世界的一切，本质上都是**状态 + 规则 + 约定**。在计算机中，没有“天然正确”，只有“设计选择”。

> 为什么计算机学生要学习模拟电路？  
> 计算机在逻辑上是离散的，在物理上是连续的。模拟电路的工程师命是在连续世界中狗再出可信赖的离散抽象。

这章讨论的问题是：**“世界如何被离散化”**

### 信息 (Information)

在工程领域里，信息 (Information) 是系统中可被可靠区分、存储和操纵的状态集合。信息的存在以**物理可区分性**作为前提。

### 状态 (State)

计算机中一切的高级概念都建立在状态之上。

工程系统的核心目标是：**在约束条件下，精确控制状态随时间的变化**。因此，一个“合格的工程状态”必须：

- 可区分 (Distinguishability)
- 可保持 (Stability)
- 可转换 (Controllability)
- 可复现 (Resproducibility)

不满足以上条件的状态**不具备工程价值。**

因此，**状态是系统在某一确定时刻，其所有可观测变量的取值集合。**

### 二进制

二进制并非理论最优，而是**工程最优**。

在工程设计中，**稳定性 > 成本 > 性能 > 表达能力**，而在噪声环境下，二态系统具备：

- 最大容错区间
- 最小判定复杂度
- 最低实现成本

因此成为主流工程选择。

### 比特 (bit) 

bit 是一个最小信息单元，1 bit对应一个**可以被可靠区分的二态系统**

因此，bit 是**工程单位**， 而不是数学概念或者数字

### 状态组合：复杂性的来源

单个 bit 很简单，但工程的力量来自于**大量简单状态的组合**。

>1 bit 只有两种状态  
>8 bit 有256种状态  
>32 bit 大约有43亿种状态  
>64 bit 在工程上“几乎无限”  

工程复杂性来源于**状态空间的指数增长**，系统能力通过**规模化组合**获得，而并非是复杂单元。这是计算机系统可扩展性的根本原因。

### 语义和表示的区别

计算机内部只有：

- 0
- 1
- 状态变化

计算机系统只处理表示 (Representation) ，不处理语义 (Semantics) 。

而语义存在于人类的头脑中。因此：**语义来自约定，而不是机器理解** 。

这是工程系统保持确定性的必要条件。

### 编码 (Encoding)

**编码是人类为状态机和赋予操作规则和解释规则的工程协议。**

---

## 3. 抽象 (Abstraction)：人类对抗复杂性的唯一武器

“人类如何在不可理解的复杂系统之上继续设计系统”

工程能力 = 构建正确抽象的能力
工程能力 ≠ 掌握更多细节的能力

### 复杂性

在工程领域，有一个不可回避的事实：**任何有实际价值的系统，其复杂性都必然超过单个工程师的理解能力。**

#### 复杂性的来源

- 状态数量的指数级增长
- 组件数量的增加
- 组件之间的相互作用

**复杂性不是失败，而是规模的必然结果。**

### 抽象 (Abstraction)

抽象是一种**有意忽略实现细节，仅保留对当前层级设计决策有意义属性的建模方式。**抽象是一种有损建模，是服务于设计目标的选择。
抽象不是为了“简单”，而是为了“可控”。
抽象不是“我相信你没问题”，而是“我只允许你这样表现”

> 抽象的目标不是让系统“更简单”，而是让复杂性“被隔离在正确的位置”。

抽象一旦失败，将导致：
- 接口泄露实现细节
- 层次间强耦合
- 系统无法演进
- 修改成本指数级上升

**大多数软件灾难，本质上都是抽象失败。常见的系统性失效，几乎都源于抽象边界被绕过或被侵蚀。**

典型表现包括：
- 依赖为生命的内部状态
- 通过“副作用”通信
- 为性能牺牲接口约束

**人类依靠抽象在不可理解的复杂系统之上继续设计系统。**

### 抽象的代价

- 信息丢失
- 性能损耗
- 控制力下降
- 间接性增加

因此，**工程的关键不在于避免代价，而在于“接受可控的代价”**

### 抽象层 (Layer)

抽象层是**对系统复杂性进行垂直切分的工程结构。**

每一层都具有明确职责：

- 向上：提供能力
- 向下：隐藏细节

**当高层模块以来底层实现细节的时候，系统的可演进性就会丧失。**

#### 抽象层存在的必要条件

一个合理的抽象层必须满足：

- 职责单一
- 边界清晰
- 实现可替换
- 接口稳定

### 计算机系统是“抽象的堆叠提”

现在计算机系统 = 多层抽象的严格叠加

```
物理硬件 - 硬件抽象（指令、寄存器） - 操作系统 - 运行环境 - 编程语言抽象 - 应用系统
```

这之中每一层都**假设下层“可靠存在”，**都**拒绝理解下层细节。**

---


## 4. 系统、模块与接口：抽象如何在工程中执行

这章讨论的问题是：**“系统如何被拆解”**

### 工程系统的基本假设

工程的研究目的是：**在给定的约束下，如何构造可预设、可验证、可复用的系统。**

任何工程系统都应当满足：
- 行为可被定义
- 边界可被识别
- 变化可被限制

### 系统 (System)

系统是**由多个相互作用的组件组成的整体，其对外行为不等价于组件行为的简单叠加。**

工程关注系统，是因为故障通常出现在交互处，复杂性集中在连接关系上。

### 模块 (Module)

模块是**系统种具有明确职责和封闭实现的功能单元。**

模块设计的工程目标：
- 降低认知负载
- 隔离变化
- 支持并行开发

一个模块要在工程上成立，必须满足：
- 指责单一
- 内部高内聚
- 对外低耦合
- 实现可替换

> **系统的崩溃很少是因为“模块写错”，几乎总是因为“模块之间的契约被破坏”。**  
> 这是调试复杂系统的第一原则

#### 计算机系统中的典型模块化结构

> 应用层
>   ├─ 业务逻辑模块
>   └─ 数据处理模块
>         ↓
> 编程语言运行时
>         ↓
> 操作系统
>   ├─ 进程管理
>   ├─ 内存管理
>   └─ I/O 子系统
>         ↓
> 硬件抽象层
>         ↓
> 物理硬件

#### 编写模块的判断标注

- 能否清晰定义模块职责？
- 接口是否足够小且稳定？
- 是否存在跨层依赖？
- 修改是否会泄漏到不该变化的地方？

#### 计算机系统不是“一个整体”，而是**强制模块化的结果**：上面的每一层都只通过接口向上提供能力。

### 接口 (Interface)

接口是**抽象层对外暴露的全部信息集合**，是**模块对外暴露的全部可观察行为集合**。

- 系统之间应当**只能通过接口交互。**
- 接口之外的细节视为不存在。

**接口定义了“允许依赖什么”**

接口是对复杂性的主动压制手段。


## 5. 为什么所有可扩展的计算机系统都必须分层

分层不是一种风格选择，而是大规模系统在认知与演化上的必然结果。

这章我们讨论的问题是，**“结构如何被约束”**

### 分层 (Layering)

分层式**一种结构化的约束**：
- 系统被划分为若干层级，每一层只依赖其下层提供的抽象能力，并仅通过明确定义的接口向上提供服务。

#### Keyword

- 单向依赖
- 能力封装
- 接口通信

#### 工程目标

分层不是为了“好看”，而是为了满足一下工程目标：

- 限制依赖方向
- 控制变化传播路径
- 隔离认知复杂度
- 支持系统长期演化

如果一个结构做不到这四点，它在工程上是失败的。

#### 工程警报

- 上层绕过接口直接访问下层细节
- 为性能“临时破例”跨层调用
- 下层为上层需求做定制逻辑
- 修改一行代码，需要全系统测试

### 为什么“模块化还不够”

模块 = 职责封装

但在大型系统中，仅有模块会导致：
- 依赖网状增长
- 修改影响面不可预测
- 全局复杂度时空

> 模块解决“局部复杂性”
> 分层解决“全局复杂性”

> 分层不会降低性能，短期局部性能可能下降，长期系统性能与可优化性显著上升。
>> - 清洗边界允许局部优化
>> - 层内可替换实现
>> - 系统行为更可预测
> 分层不是限制工程师能力，而是防止无意中破坏系统。

### “层”不是物理存在，而是工程协议

> 层不是一个文件夹、不是一个目录、不是一个组件数量问题

层是：

- 依赖规则
- 抽象边界
- 架构约束

**违反以来规则，就等于“打破分层”

### 分层如何驯服复杂性

> 任何修改都会产生不可预测的连锁反应

分层通过一下方式解决：
- 修改被限制在某一层
- 跨层影响被接口吸收
- 系统其余部分保持不变

### 典型计算机系统的分层结构

应用层 - 业务逻辑、策略、规则

编程语言 / 运行时层 - 抽象机器、内存模型、执行语义

操作系统层 - 资源管理、隔离、调皮

硬件抽象层 - 指令集、寄存器、中断

物理硬件层 - 连续物理系统

> 为上层提供一个“更可控的世界”

### 工程师问题集：

- 系统分了几层？
- 依赖方向是否单一？
- 哪一层最稳定？
- 哪一层变化最频繁？
- 边界是否被严格执行？

---

# 计算与执行（动态过渡层）

## 6. 计算与执行：状态如何随时间演化？

### 计算 (Calculate)

计算是**在离散时间轴上，对系统状态进行一系列确定性的状态变换。**

所以，计算不是“算结果”，而是**状态随时间的确定性演化。**

#### 四个工程要素

- 状态 (State)
- 时间 (Time)
- 变换规则 (Transition Function)
- 执行顺序 (Ordering)

### 状态

补充一个状态的工程定义：**在某一时刻，系统中所有可观测、可持久、可参与决策的信息的全集。**

**状态是系统的唯一真实存在**

它具有三个硬约束：
| 约束    | 含义          |
| ----- | ----------- |
| 可观测   | 能被系统内部或外部读取 |
| 可保持   | 不依赖瞬时物理过程   |
| 可影响未来 | 会改变后续行为     |

所以：
- CPU 寄存器是状态
- 内存是状态
- 磁盘是状态
- 网络缓冲区是状态
- 电流瞬态**不是状态**

### 时间

关于计算机中的“离散时间假设”

#### 我们强制世界“离散化”

计算机工程**不接受连续性。**因此，我们假设**事件被离散切分为一个个不可再分的执行步 (step/cycle)

#### 离散化的代价与收益

| 代价    | 收益          |
| ----- | ----------- |
| 精度有限   | 可预测 |
| 延迟存在   | 可验证   |
| 抖动不可避免 | 可复现     |

**工程世界不能失去不确定性**

#### 一步执行代表着什么？

一步执行意味着，读取当前状态，根据规则计算，写入新状态

因此这个过程是：
- 原子的
- 有序的
- 不可回滚的

### 计算机的真正模型

从工程角度，所有计算机系统都可以抽象为 “离散时间状态转移系统 (Discrete State Transition System)”
因此，我们可以认为**计算机系统 = 状态空间 + 状态转换规则 + 人类约定**

可以形式化表示为

```r
S(t+1) = F(S(t), I(t))
```

其中：
- `S(t)`：当前系统状态
- `I(t)`: 输入（可选）
- `F`: 确定性转移函数

> 需要注意的是，程序并不是F，程序只是F的一种编码形式

### 执行

“执行”不是“运行代码”

执行是**驱动状态转移的物理与逻辑机制。**是物理与逻辑共同完成的过程。

代码只是**对状态转移规则的描述**，但真正执行转移的是**时钟、控制逻辑、存储读写、物理能量。**

**是否“有意义”不是执行的判据，**这也是为什么“死循环”仍然会执行。因为：
- 状态在变化（计数器、指针、时间）
- 时间再推进
- 控制逻辑仍然在工作

### 顺序性

状态转移的顺序从哪里来？
- 控制机制 (Control)

我们先进行抽象的答案的概括：
- 顺序不是自然产生的，而是**强制规定的。**
- 顺序的来源决定了系统的可预测性。
- 顺序不是必然，而是设计结果。

### 工程视角

因此，我们要
- 把程序看成状态机
- 把 bug 看成非法状态转移
- 把性能问题看成时间步过多
- 把并发问题堪称顺序失控。

## 7. 控制：谁决定“下一步做什么”？

**没有控制，就没有计算。**

### 控制

控制是**对状态转移顺序的强制规定机制。** 控制解决的不是“做什么”，而是 **“什么时候、以什么顺序、由谁来触发状态转移”**

**控制解决的不是 if/else, for/while, 函数调用。**

### 为什么顺序是工程问题而不是语法问题

在数学中，f(g(x)) 和 g(f(x)) 只要定义良好即可。但是在工程中，顺序错误 = 系统崩溃。**物理世界不支持交换律。**

| 顺序类型 | 工程含义           |
| ---- | -------------- |
| 因果顺序 | 必须先发生 A，才能发生 B |
| 资源顺序 | 共享资源不能被同时破坏    |
| 时间顺序 | 事件必须发生在时间窗口内   |

控制机制的职责，就是**同时满足这三种约束。**

### 控制的工程抽象

从工程角度，控制可以被建模为**一个驱动状态转移的决策系统。**
形式化描述：
```ini
NextState = Control(CurrentState, Inputs, Events)
```
因此，Control ≠ Program, Control ≠ Logic

**Control 是决策 + 强制执行**

### 控制与执行的分离

> **决策系统必须与执行系统解耦**

- 决策可以改变
- 执行必须稳定
- 能量流与信息流不同

这直接导致了：
- 控制单元 vs 运算单元
- 调度器 vs 计算任务
- 操作系统 vs 应用程序


# 计算机系统结构（实现层）

## 8. 物理层：我们在操纵什么？
## 9. 计算层：什么叫“计算”？
## 10. 存储层：状态如何被记住？
## 11. 控制层：程序如何控制机器？
## 12. 操作系统的工程职责

# 软件与编程的本质（抽象机器层）

## 13. 程序不是代码，是“状态机”
## 14. 编程语言在系统中的位置
## 15. 运行时与抽象机器
## 16. 软件为什么一定会复杂？
## 17. 软件工程的真实难点

# 成为工程师的视角（方法论层）

## 18. 什么是“好设计”
## 19. 工程中的权衡与约束
## 20. 为什么系统会崩？
## 21. 从需求到系统
## 22. 学任何新技术的通用方法

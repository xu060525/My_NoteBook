# 计算机工程世界观

## 1. 什么是计算机

在工程系统语境中：计算机是一种通过物理可实现的确定性机制，对离散信息状态进行表示、存储、转换与控制的通用工程系统。

该定义强调计算机的四个核心要素：

- 物理可实现性
- 确定性
- 离散状态
- 通用性

让我们对这句话进行拆解：

### 工程系统

一个工程系统，必须满足：
- 可预测
- 可重复
- 可控制
- 可扩展

计算机最重要的不是“智能”，而是**极度可控**

### 信息状态

- 状态 --> 系统在某一时刻内的全部内部情况
- 信息 --> 对状态的抽象描述

计算机只进行**状态的操纵**。

### 确定性 (Determinism)

确定性是**工程的底线**，也是**工程系统可被设计、验证和复现的前提条件**。

确定性指的是**在相同的初始状态与相同输入条件下，系统的状态演化路径是唯一确定的。**

没有确定性，就无法调试、无法复现、无法扩展，也无法工程复用。

### 离散状态与工程可控性

计算机系统基于**离散状态空间**，原因在于：

- 离散状态可以被可靠区分
- 离散状态可以被精确复制
- 离散状态可以被形式化建模

连续系统难以满足工程控制需求，因此被抽象、量化或离散化。

### 信息处理

计算机对信息的处理，可以被工程化地拆分为四类操作：

- **表示 (Representation)**  
将物理状态映射为离散符号
- **存储 (Storage)**  
在时间维度上保持状态
- **转换 (Transformation)**  
按规则转变状态
- **控制 (Control)**
决定何时、以何种顺序进行状态转换

这四类操作定义了计算机系统边界的能力。

### 通用性 (Generaliity)

**通用性不是能力更强，而是约束更少。**

计算机的“通用性”来源于：

- 状态转换规则可以被描述为数据
- 控制行为逻辑可以被重配置
- 行为由外部输入定义

也就是说：**程序本身也是信息状态。**

### 程序

**程序是对状态空间及其转换规则的形式化描述。**

程序不是“指令列表”，而是对系统行为的约束，以及对状态演化路径的编码。

### 计算机的一级公理

计算机系统 = 离散状态空间

- 确定性状态转换机制
- 可配置的控制规则

> 需要注意的是，**计算机不具备认知属性**，所有的“智能”，“理解”，“决策”都是观察者施加的语义解释，而非系统属性。

---


## 2. 信息、状态与二进制

计算机世界的一切，本质上都是**状态 + 规则 + 约定**。在计算机中，没有“天然正确”，只有“设计选择”。

### 信息 (Information)

在工程领域里，信息 (Information) 是系统中可被可靠区分、存储和操纵的状态集合。信息的存在以**物理可区分性**作为前提。

### 状态 (State)

计算机中一切的高级概念都建立在状态之上。

工程系统的核心目标是：**在约束条件下，精确控制状态随时间的变化**。因此，一个“合格的工程状态”必须：

- 可区分 (Distinguishability)
- 可保持 (Stability)
- 可转换 (Controllability)
- 可复现 (Resproducibility)

不满足以上条件的状态**不具备工程价值。**

因此，**状态是系统在某一确定时刻，其所有可观测变量的取值集合。**

### 二进制

二进制并非理论最优，而是**工程最优**。

在工程设计中，**稳定性 > 成本 > 性能 > 表达能力**，而在噪声环境下，二态系统具备：

- 最大容错区间
- 最小判定复杂度
- 最低实现成本

因此成为主流工程选择。

### 比特 (bit) 

bit 是一个最小信息单元，1 bit对应一个**可以被可靠区分的二态系统**

因此，bit 是**工程单位**， 而不是数学概念或者数字

### 状态组合：复杂性的来源

单个 bit 很简单，但工程的力量来自于**大量简单状态的组合**。

>1 bit 只有两种状态  
>8 bit 有256种状态  
>32 bit 大约有43亿种状态  
>64 bit 在工程上“几乎无限”  

工程复杂性来源于**状态空间的指数增长**，系统能力通过**规模化组合**获得，而并非是复杂单元。这是计算机系统可扩展性的根本原因。

### 语义和表示的区别

计算机内部只有：

- 0
- 1
- 状态变化

计算机系统只处理表示 (Representation) ，不处理语义 (Semantics) 。

而语义存在于人类的头脑中。因此：**语义来自约定，而不是机器理解** 。

这是工程系统保持确定性的必要条件。

### 编码 (Encoding)

**编码是人类为状态机和赋予操作规则和解释规则的工程协议。**

---

## 3. 抽象 (Abstraction)：人类对抗复杂性的唯一武器

“人类如何在不可理解的复杂系统之上继续设计系统”

工程能力 = 构建正确抽象的能力
工程能力 ≠ 掌握更多细节的能力

### 复杂性

在工程领域，有一个不可回避的事实：**任何有实际价值的系统，其复杂性都必然超过单个工程师的理解能力。**

#### 复杂性的来源

- 状态数量的指数级增长
- 组件数量的增加
- 组件之间的相互作用

**复杂性不是失败，而是规模的必然结果。**

### 抽象 (Abstraction)

抽象是一种**有意忽略实现细节，仅保留对当前层级设计决策有意义属性的建模方式。**抽象是一种有损建模，是服务于设计目标的选择。
抽象不是为了“简单”，而是为了“可控”。

> 抽象的目标不是让系统“更简单”，而是让复杂性“被隔离在正确的位置”。

抽象一旦失败，将导致：
- 接口泄露实现细节
- 层次间强耦合
- 系统无法演进
- 修改成本指数级上升

**大多数软件灾难，本质上都是抽象失败。**

### 抽象的代价

- 信息丢失
- 性能损耗
- 控制力下降
- 间接性增加

因此，**工程的关键不在于避免代价，而在于“接受可控的代价”**

### 抽象层 (Layer)

抽象层是**对系统复杂性进行垂直切分的工程结构。**

每一层都具有明确职责：

- 向上：提供能力
- 向下：隐藏细节

#### 抽象层存在的必要条件

一个合理的抽象层必须满足：

- 职责单一
- 边界清晰
- 实现可替换
- 接口稳定

### 接口 (Interface)：抽象的唯一合法出口

接口是**抽象层对外暴露的全部信息集合**

- 系统之间应当**只能通过接口交互。**
- 接口之外的细节视为不存在。

### 计算机系统是“抽象的堆叠提”

现在计算机系统 = 多层抽象的严格叠加

```
物理硬件 - 硬件抽象（指令、寄存器） - 操作系统 - 运行环境 - 编程语言抽象 - 应用系统
```

这之中每一层都**假设下层“可靠存在”，**都**拒绝理解下层细节。**

---


## 4. 系统、模块与接口
## 5. 为什么一定要分层？

# 计算机系统结构

## 6. 物理层：我们在操纵什么？
## 7. 计算层：什么叫“计算”？
## 8. 存储层：状态如何被记住？
## 9. 控制层：程序如何控制机器？
## 10. 操作系统的工程职责

# 软件与编程的本质

## 11. 程序不是代码，是“状态机”
## 12. 编程语言在系统中的位置
## 13. 运行时与抽象机器
## 14. 软件为什么一定会复杂？
## 15. 软件工程的真实难点

# 成为工程师的视角

## 16. 什么是“好设计”
## 17. 工程中的权衡与约束
## 18. 为什么系统会崩？
## 19. 从需求到系统
## 20. 学任何新技术的通用方法
